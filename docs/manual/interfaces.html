<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>インターフェース · The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="introduction.html">はじめに</a></li><li><a class="toctext" href="getting-started.html">Juliaをはじめる</a></li><li><a class="toctext" href="variables.html">変数</a></li><li><a class="toctext" href="integers-and-floating-point-numbers.html">整数と浮動小数点数</a></li><li><a class="toctext" href="mathematical-operations.html">算術処理と基本的な関数</a></li><li><a class="toctext" href="complex-and-rational-numbers.html">複素数と有理数</a></li><li><a class="toctext" href="strings.html">文字列</a></li><li><a class="toctext" href="functions.html">関数</a></li><li><a class="toctext" href="control-flow.html">制御構造</a></li><li><a class="toctext" href="variables-and-scoping.html">変数のスコープ</a></li><li><a class="toctext" href="types.html">型</a></li><li><a class="toctext" href="methods.html">メソッド</a></li><li><a class="toctext" href="constructors.html">コンストラクタ</a></li><li><a class="toctext" href="conversion-and-promotion.html">変換と昇格</a></li><li class="current"><a class="toctext" href="interfaces.html">インターフェース</a><ul class="internal"><li><a class="toctext" href="#man-interface-iteration-1">繰返し</a></li><li><a class="toctext" href="#インデックス-1">インデックス</a></li><li><a class="toctext" href="#man-interface-array-1">抽象配列</a></li></ul></li><li><a class="toctext" href="modules.html">モジュール</a></li><li><a class="toctext" href="documentation.html">Documentation</a></li><li><a class="toctext" href="metaprogramming.html">Metaprogramming</a></li><li><a class="toctext" href="arrays.html">Multi-dimensional Arrays</a></li><li><a class="toctext" href="linear-algebra.html">Linear algebra</a></li><li><a class="toctext" href="networking-and-streams.html">Networking and Streams</a></li><li><a class="toctext" href="parallel-computing.html">Parallel Computing</a></li><li><a class="toctext" href="dates.html">Date and DateTime</a></li><li><a class="toctext" href="interacting-with-julia.html">Interacting With Julia</a></li><li><a class="toctext" href="running-external-programs.html">Running External Programs</a></li><li><a class="toctext" href="calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="toctext" href="handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="environment-variables.html">Environment Variables</a></li><li><a class="toctext" href="interacting-with-julia.html">Interacting With Julia</a></li><li><a class="toctext" href="embedding.html">Embedding Julia</a></li><li><a class="toctext" href="packages.html">Packages</a></li><li><a class="toctext" href="profile.html">Profiling</a></li><li><a class="toctext" href="stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="workflow-tips.html">Workflow Tips</a></li><li><a class="toctext" href="style-guide.html">Style Guide</a></li><li><a class="toctext" href="faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="unicode-input.html">Unicode Input</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../stdlib/base.html">Essentials</a></li><li><a class="toctext" href="../stdlib/collections.html">Collections and Data Structures</a></li><li><a class="toctext" href="../stdlib/math.html">Mathematics</a></li><li><a class="toctext" href="../stdlib/numbers.html">Numbers</a></li><li><a class="toctext" href="../stdlib/strings.html">Strings</a></li><li><a class="toctext" href="../stdlib/arrays.html">Arrays</a></li><li><a class="toctext" href="../stdlib/parallel.html">Tasks and Parallel Computing</a></li><li><a class="toctext" href="../stdlib/linalg.html">Linear Algebra</a></li><li><a class="toctext" href="../stdlib/constants.html">Constants</a></li><li><a class="toctext" href="../stdlib/file.html">Filesystem</a></li><li><a class="toctext" href="../stdlib/io-network.html">I/O and Network</a></li><li><a class="toctext" href="../stdlib/punctuation.html">Punctuation</a></li><li><a class="toctext" href="../stdlib/sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="../stdlib/pkg.html">Package Manager Functions</a></li><li><a class="toctext" href="../stdlib/dates.html">Dates and Time</a></li><li><a class="toctext" href="../stdlib/iterators.html">Iteration utilities</a></li><li><a class="toctext" href="../stdlib/test.html">Unit Testing</a></li><li><a class="toctext" href="../stdlib/c.html">C Interface</a></li><li><a class="toctext" href="../stdlib/libc.html">C Standard Library</a></li><li><a class="toctext" href="../stdlib/libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="../stdlib/profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/stacktraces.html">StackTraces</a></li><li><a class="toctext" href="../stdlib/simd-types.html">SIMD Support</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../devdocs/reflection.html">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/types.html">More about types</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/libgit2.html">Base.LibGit2</a></li><li><a class="toctext" href="../devdocs/require.html">Module loading</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li><li><a class="toctext" href="../devdocs/sanitizers.html">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="interfaces.html">インターフェース</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/julia/tree/903644385b91ed8d95e5e3a5716c089dd1f1b08a/doc/src/manual/interfaces.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><p><a href="# Interfaces"></a></p><h1><a class="nav-anchor" id="インターフェース-1" href="#インターフェース-1">インターフェース</a></h1><!--
A lot of the power and extensibility in Julia comes from a collection of informal interfaces.
 By extending a few specific methods to work for a custom type, objects of that type not only
receive those functionalities, but they are also able to be used in other methods that are written
to generically build upon those behaviors.
--><p>Juliaに仮に実装されている様々なインターフェースは、この言語の力と拡張性の源となっています。 このインターフェースを独自型に特化したメソッドに拡張すると、特化したメソッドは、直接呼び出しても、汎化的に記述されたメソッドから呼び出しても、その型のオブジェクトでは機能します。</p><p><a href="## [Iteration](@id man-interface-iteration)"></a></p><h2><a class="nav-anchor" id="man-interface-iteration-1" href="#man-interface-iteration-1">繰返し</a></h2><!--

| Required methods               |                        | Brief description                                                                     |
|:------------------------------ |:---------------------- |:------------------------------------------------------------------------------------- |
| `start(iter)`                  |                        | Returns the initial iteration state                                                   |
| `next(iter, state)`            |                        | Returns the current item and the next state                                           |
| `done(iter, state)`            |                        | Tests if there are any items remaining                                                |
| **Important optional methods** | **Default definition** | **Brief description**                                                                 |
| `iteratorsize(IterType)`       | `HasLength()`          | One of `HasLength()`, `HasShape()`, `IsInfinite()`, or `SizeUnknown()` as appropriate |
| `iteratoreltype(IterType)`     | `HasEltype()`          | Either `EltypeUnknown()` or `HasEltype()` as appropriate                              |
| `eltype(IterType)`             | `Any`                  | The type the items returned by `next()`                                               |
| `length(iter)`                 | (*undefined*)          | The number of items, if known                                                         |
| `size(iter, [dim...])`         | (*undefined*)          | The number of items in each dimension, if known                                       |

| Value returned by `iteratorsize(IterType)` | Required Methods                           |
|:------------------------------------------ |:------------------------------------------ |
| `HasLength()`                              | `length(iter)`                             |
| `HasShape()`                               | `length(iter)`  and `size(iter, [dim...])` |
| `IsInfinite()`                             | (*none*)                                   |
| `SizeUnknown()`                            | (*none*)                                   |

| Value returned by `iteratoreltype(IterType)` | Required Methods   |
|:-------------------------------------------- |:------------------ |
| `HasEltype()`                                | `eltype(IterType)` |
| `EltypeUnknown()`                            | (*none*)           |

--><table><tr><th>必須メソッド</th><th> </th><th>概説</th></tr><tr><td><code>start(iter)</code></td><td> </td><td>繰り返しの初期状態を返します。</td></tr><tr><td><code>next(iter, state)</code></td><td> </td><td>現在のアイテムと次の状態を返します。</td></tr><tr><td><code>done(iter, state)</code></td><td> </td><td>残りのアイテムがあるかどうか検査します。</td></tr><tr><td><strong>重要な必須ではないメソッド</strong></td><td><strong>デフォルトのメソッド</strong></td><td><strong>概説</strong></td></tr><tr><td><code>iteratorsize(IterType)</code></td><td><code>HasLength()</code></td><td><code>HasLength()</code>, <code>HasShape()</code>, <code>IsInfinite()</code>,  <code>SizeUnknown()</code> の中で適切なもの一つ</td></tr><tr><td><code>iteratoreltype(IterType)</code></td><td><code>HasEltype()</code></td><td><code>EltypeUnknown()</code>と<code>HasEltype()</code>のどちらか適切のもの</td></tr><tr><td><code>eltype(IterType)</code></td><td><code>Any</code></td><td><code>next()</code>が返すアイテムの型</td></tr><tr><td><code>length(iter)</code></td><td>(<em>undefined</em>)</td><td>アイテムの数(既知の場合)</td></tr><tr><td><code>size(iter, [dim...])</code></td><td>(<em>undefined</em>)</td><td>各次元のアイテムの数(既知の場合)</td></tr></table><table><tr><th><code>iteratorsize(IterType)</code>の戻り値</th><th>必要なメソッド</th></tr><tr><td><code>HasLength()</code></td><td><code>length(iter)</code></td></tr><tr><td><code>HasShape()</code></td><td><code>length(iter)</code>と<code>size(iter, [dim...])</code></td></tr><tr><td><code>IsInfinite()</code></td><td>(<em>none</em>)</td></tr><tr><td><code>SizeUnknown()</code></td><td>(<em>none</em>)</td></tr></table><table><tr><th><code>iteratoreltype(IterType)</code>の戻り値</th><th>必要なメソッド</th></tr><tr><td><code>HasEltype()</code></td><td><code>eltype(IterType)</code></td></tr><tr><td><code>EltypeUnknown()</code></td><td>(<em>none</em>)</td></tr></table><!--
Sequential iteration is implemented by the methods [`start()`](@ref), [`done()`](@ref), and [`next()`](@ref). Instead
of mutating objects as they are iterated over, Julia provides these three methods to keep track
of the iteration state externally from the object. The `start(iter)` method returns the initial
state for the iterable object `iter`. That state gets passed along to `done(iter, state)`, which
tests if there are any elements remaining, and `next(iter, state)`, which returns a tuple containing
the current element and an updated `state`. The `state` object can be anything, and is generally
considered to be an implementation detail private to the iterable object.
--><p>順次実行される繰返し処理は、<a href="../stdlib/collections.html#Base.start"><code>start()</code></a>, <a href="../stdlib/collections.html#Base.done"><code>done()</code></a>, <a href="../stdlib/collections.html#Base.next"><code>next()</code></a> のメソッドをつかって実装されています。 Juliaでは、繰返し処理の状態の追跡は、この3つのメソッドを使ってオブジェクトの外部から行われ、処理の行われるオブジェクトには変更を加えません。 この<code>start(iter)</code>メソッドは、イテラブルオブジェクト<code>iter</code>の初期状態を返し、 その状態は<code>done(iter, state)</code>、<code>next(iter, state)</code>と順に渡されます。 <code>done(iter, state)</code>は残りの要素があるかどうかを検査し、<code>next(iter, state)</code>は現在の要素と更新された<code>state</code>オブジェクトを含むタプルを返します。 <code>state</code>オブジェクトは何でも構いませんが、通常はイテラブルオブジェクト内でプライベートな実装の詳細を示すものでしょう。</p><!--
Any object defines these three methods is iterable and can be used in the [many functions that rely upon iteration](@ref lib-collections-iteration).
It can also be used directly in a `for` loop since the syntax:
--><p>これらの3つのメソッドが定義されたオブジェクトはすべてイテラブルであり、[繰返しを使う多数の関数]（@ ref lib-collections-iteration）で使用できます。 また以下のような構文で<code>for</code>ループ内で直接使用することもできます。</p><pre><code class="language-julia">for i in iter   # or  &quot;for i = iter&quot;
    # body
end</code></pre><!--
is translated into:
--><p>上記の構文は以下のように変換されます。</p><pre><code class="language-julia">state = start(iter)
while !done(iter, state)
    (i, state) = next(iter, state)
    # body
end</code></pre><!--
A simple example is an iterable sequence of square numbers with a defined length:
--><p>簡単な例は、イテラブルな長さの決まった平方数の数列です。</p><pre><code class="language-jldoctest">julia&gt; struct Squares
           count::Int
       end

julia&gt; Base.start(::Squares) = 1

julia&gt; Base.next(S::Squares, state) = (state*state, state+1)

julia&gt; Base.done(S::Squares, state) = state &gt; S.count

julia&gt; Base.eltype(::Type{Squares}) = Int # Note that this is defined for the type

julia&gt; Base.length(S::Squares) = S.count</code></pre><!--
With only [`start`](@ref), [`next`](@ref), and [`done`](@ref) definitions, the `Squares` type is already pretty powerful.
We can iterate over all the elements:
--><p><a href="../stdlib/collections.html#Base.start"><code>start</code></a>, <a href="../stdlib/collections.html#Base.next"><code>next</code></a>,  <a href="../stdlib/collections.html#Base.done"><code>done</code></a> の定義だけでも、<code>Squares</code>型はすでにかなり強力です。 すべての要素に対する繰り返し処理を実行できます。</p><pre><code class="language-jldoctest">julia&gt; for i in Squares(7)
           println(i)
       end
1
4
9
16
25
36
49</code></pre><!--
We can use many of the builtin methods that work with iterables, like [`in()`](@ref), [`mean()`](@ref) and [`std()`](@ref):
--><p><a href="../stdlib/collections.html#Base.in"><code>in()</code></a>, <a href="../stdlib/math.html#Base.mean"><code>mean()</code></a>, <a href="../stdlib/math.html#Base.std"><code>std()</code></a> のような多くの標準装備のメソッドがイテラブルオブジェクトで動作します。</p><pre><code class="language-jldoctest">julia&gt; 25 in Squares(10)
true

julia&gt; mean(Squares(100))
3383.5

julia&gt; std(Squares(100))
3024.355854282583</code></pre><!--
There are a few more methods we can extend to give Julia more information about this iterable
collection.  We know that the elements in a `Squares` sequence will always be `Int`. By extending
the [`eltype()`](@ref) method, we can give that information to Julia and help it make more specialized
code in the more complicated methods. We also know the number of elements in our sequence, so
we can extend [`length()`](@ref), too.
--><p>さらに、対象とするイテラブルコレクションに関する詳しい情報を与えるために、拡張して使うメソッドがJuliaにはいくつかあります。 <code>Squares</code>の数列の要素は常に<code>Int</code>であることがわかっています。  <a href="../stdlib/collections.html#Base.eltype"><code>eltype()</code></a>メソッドを拡張して、この情報をJuliaに渡すと、もっと複雑なメソッドでも、もっと型に特化したコードを作成するのに役立てることができます。 シーケンスの要素数もわかっているので<a href="../stdlib/arrays.html#Base.length-Tuple{AbstractArray}"><code>length()</code></a>も拡張することもできます。</p><!--
Now, when we ask Julia to [`collect()`](@ref) all the elements into an array it can preallocate a `Vector{Int}`
of the right size instead of blindly [`push!`](@ref)ing each element into a `Vector{Any}`:
--><p>ここまでくれば、Juliaで、 すべての要素を<a href="../stdlib/collections.html#Base.collect-Tuple{Any}"><code>collect()</code></a> を使って配列化する際に、 <code>Vector{Int}</code>のように 正しいサイズに事前に割り当てることができます。<a href="../stdlib/collections.html#Base.push!"><code>push!</code></a>を使って盲目的に各要素を<code>Vector{Any}</code>におしこまなくてもよいのです。</p><pre><code class="language-jldoctest">julia&gt; collect(Squares(10))&#39; # transposed to save space
1×10 RowVector{Int64,Array{Int64,1}}:
 1  4  9  16  25  36  49  64  81  100</code></pre><!--
While we can rely upon generic implementations, we can also extend specific methods where we know
there is a simpler algorithm. For example, there's a formula to compute the sum of squares, so
we can override the generic iterative version with a more performant solution:
--><p>汎化的な実装のまま使うこともできますが、もっと単純なアルゴリズムがあると分かっている場合は、特化したメソッドに拡張することもできます。 たとえば、平方和を算出する公式があれば、汎化的な繰返しをもっと効率的な解法で上書きすることができます。</p><pre><code class="language-jldoctest">julia&gt; Base.sum(S::Squares) = (n = S.count; return n*(n+1)*(2n+1)÷6)

julia&gt; sum(Squares(1803))
1955361914</code></pre><!--
This is a very common pattern throughout the Julia standard library: a small set of required methods
define an informal interface that enable many fancier behaviors. In some cases, types will want
to additionally specialize those extra behaviors when they know a more efficient algorithm can
be used in their specific case.
--><p>これは、Julia標準ライブラリ全体に非常によくあるパターンです。 少数の必須メソッドによって仮実装のインターフェイスが定義され、多くの便利な動作が利用可能となっています。 もっと効率的なアルゴリズムを使用できる場合には、さらに型に特化させてその動作を行うことができます。</p><p><a href="## Indexing"></a></p><h2><a class="nav-anchor" id="インデックス-1" href="#インデックス-1">インデックス</a></h2><!--
| Methods to implement | Brief description                |
|:-------------------- |:-------------------------------- |
| `getindex(X, i)`     | `X[i]`, indexed element access   |
| `setindex!(X, v, i)` | `X[i] = v`, indexed assignment   |
| `endof(X)`           | The last index, used in `X[end]` |
--><table><tr><th>実装すべきメソッド</th><th>概説</th></tr><tr><td><code>getindex(X, i)</code></td><td><code>X[i]</code>, インデックスによる要素の参照</td></tr><tr><td><code>setindex!(X, v, i)</code></td><td><code>X[i] = v</code>,  インデックスによる代入</td></tr><tr><td><code>endof(X)</code></td><td>インデックスの最後尾,  <code>X[end]</code>で使われる</td></tr></table><!--
For the `Squares` iterable above, we can easily compute the `i`th element of the sequence by squaring
it.  We can expose this as an indexing expression `S[i]`. To opt into this behavior, `Squares`
simply needs to define [`getindex()`](@ref):
--><p>上記の<code>Squares</code>イテラブルでは、数列の<code>i</code>番目は、2乗すれば簡単に算出できます。 <code>S[i]</code>というインデックス式で、これを公開することができます。 <code>Squares</code> に<a href="../stdlib/arrays.html#Base.getindex-Tuple{Type,Vararg{Any,N} where N}"><code>getindex()</code></a> を定義すればいいだけです。</p><pre><code class="language-jldoctest">julia&gt; function Base.getindex(S::Squares, i::Int)
           1 &lt;= i &lt;= S.count || throw(BoundsError(S, i))
           return i*i
       end

julia&gt; Squares(100)[23]
529</code></pre><!--
Additionally, to support the syntax `S[end]`, we must define [`endof()`](@ref) to specify the last valid
index:
--><p>さらに、<code>S[end]</code>構文を使えるようにするには、<a href="../stdlib/collections.html#Base.endof"><code>endof()</code></a>を定義して有効な最後尾のインデックスを指定する必要があります。</p><pre><code class="language-jldoctest">julia&gt; Base.endof(S::Squares) = length(S)

julia&gt; Squares(23)[end]
529</code></pre><!--
Note, though, that the above *only* defines [`getindex()`](@ref) with one integer index. Indexing with
anything other than an `Int` will throw a [`MethodError`](@ref) saying that there was no matching method.
In order to support indexing with ranges or vectors of `Int`s, separate methods must be written:
--><p>ただし、上記は <a href="../stdlib/arrays.html#Base.getindex-Tuple{Type,Vararg{Any,N} where N}"><code>getindex()</code></a> を1つの整数インデックスで<strong>のみ</strong>定義していることに注意してください。 <code>Int</code>以外のものを使ってインデックスを使うと <a href="../stdlib/base.html#Base.MethodError"><code>MethodError</code></a> を投げて、適合するメソッドが存在しないというメッセージが表示されるでしょう。 範囲や<code>Int</code>のベクトルに対してインデックスをつかう場合は、別のメソッドを記述する必要があります。</p><pre><code class="language-jldoctest">julia&gt; Base.getindex(S::Squares, i::Number) = S[convert(Int, i)]

julia&gt; Base.getindex(S::Squares, I) = [S[i] for i in I]

julia&gt; Squares(10)[[3,4.,5]]
3-element Array{Int64,1}:
  9
 16
 25</code></pre><!--
While this is starting to support more of the [indexing operations supported by some of the builtin types](@ref man-array-indexing),
there's still quite a number of behaviors missing. This `Squares` sequence is starting to look
more and more like a vector as we've added behaviors to it. Instead of defining all these behaviors
ourselves, we can officially define it as a subtype of an [`AbstractArray`](@ref).
--><p>[一部の標準装備の型で可能なインデックス操作]（@ ref man-array-indexing）をがけっこう使えるようになりましたが、依然として動作しないものが多くあります。 この<code>Squares</code>シーケンスに、もっと動作を加えると、ますますベクトルのように見えます。 これらの動作はすべてを自前で定義しなくても、正式な <a href="../stdlib/arrays.html#Core.AbstractArray"><code>AbstractArray</code></a>のサブタイプとして定義することができます。</p><p><a href="## [Abstract Arrays](@id man-interface-array)"></a></p><h2><a class="nav-anchor" id="man-interface-array-1" href="#man-interface-array-1">抽象配列</a></h2><!--
| Methods to implement                            |                                          | Brief description                                                                     |
|:----------------------------------------------- |:---------------------------------------- |:------------------------------------------------------------------------------------- |
| `size(A)`                                       |                                          | Returns a tuple containing the dimensions of `A`                                      |
| `getindex(A, i::Int)`                           |                                      ｓ    | (if `IndexLinear`) Linear scalar indexing                                              |
| `getindex(A, I::Vararg{Int, N})`                |                                          | (if `IndexCartesian`, where `N = ndims(A)`) N-dimensional scalar indexing                 |
| `setindex!(A, v, i::Int)`                       |                                          | (if `IndexLinear`) Scalar indexed assignment                                           |
| `setindex!(A, v, I::Vararg{Int, N})`            |                                          | (if `IndexCartesian`, where `N = ndims(A)`) N-dimensional scalar indexed assignment       |
| **Optional methods**                            | **Default definition**                   | **Brief description**                                                                 |
| `IndexStyle(::Type)`                            | `IndexCartesian()`                       | Returns either `IndexLinear()` or `IndexCartesian()`. See the description below.      |
| `getindex(A, I...)`                             | defined in terms of scalar `getindex()`  | [Multidimensional and nonscalar indexing](@ref man-array-indexing)                    |
| `setindex!(A, I...)`                            | defined in terms of scalar `setindex!()` | [Multidimensional and nonscalar indexed assignment](@ref man-array-indexing)          |
| `start()`/`next()`/`done()`                     | defined in terms of scalar `getindex()`  | Iteration                                                                             |
| `length(A)`                                     | `prod(size(A))`                          | Number of elements                                                                    |
| `similar(A)`                                    | `similar(A, eltype(A), size(A))`         | Return a mutable array with the same shape and element type                           |
| `similar(A, ::Type{S})`                         | `similar(A, S, size(A))`                 | Return a mutable array with the same shape and the specified element type             |
| `similar(A, dims::NTuple{Int})`                 | `similar(A, eltype(A), dims)`            | Return a mutable array with the same element type and size *dims*                     |
| `similar(A, ::Type{S}, dims::NTuple{Int})`      | `Array{S}(dims)`                         | Return a mutable array with the specified element type and size                       |
| **Non-traditional indices**                     | **Default definition**                   | **Brief description**                                                                 |
| `indices(A)`                                    | `map(OneTo, size(A))`                    | Return the `AbstractUnitRange` of valid indices                                       |
| `Base.similar(A, ::Type{S}, inds::NTuple{Ind})` | `similar(A, S, Base.to_shape(inds))`     | Return a mutable array with the specified indices `inds` (see below)                  |
| `Base.similar(T::Union{Type,Function}, inds)`   | `T(Base.to_shape(inds))`                 | Return an array similar to `T` with the specified indices `inds` (see below)          |
--><table><tr><th>実装すべきメソッド</th><th> </th><th>概説</th></tr><tr><td><code>size(A)</code></td><td> </td><td><code>A</code>の次元を含むタプルを返す</td></tr><tr><td><code>getindex(A, i::Int)</code></td><td> </td><td>( <code>IndexLinear</code>)線形スカラインデックスによる参照</td></tr><tr><td><code>getindex(A, I::Vararg{Int, N})</code></td><td> </td><td>( <code>IndexCartesian</code>,<code>N = ndims(A)</code>) N次元のスカラインデックスにによる参照</td></tr><tr><td><code>setindex!(A, v, i::Int)</code></td><td> </td><td>( <code>IndexLinear</code>) 線形スカラインデックスによる代入</td></tr><tr><td><code>setindex!(A, v, I::Vararg{Int, N})</code></td><td> </td><td>( <code>IndexCartesian</code>, <code>N = ndims(A)</code>) N次元のスカラインデックスによる代入</td></tr><tr><td><strong>省略可能なメソッド</strong></td><td><strong>デフォルトの定義</strong></td><td><strong>概説</strong></td></tr><tr><td><code>IndexStyle(::Type)</code></td><td><code>IndexCartesian()</code></td><td><code>IndexLinear()</code> と <code>IndexCartesian()</code>のどちらかを返す。下記参照</td></tr><tr><td><code>getindex(A, I...)</code></td><td>スカラーの  <code>getindex()</code>による定義</td><td><a href="arrays.html#man-array-indexing-1">多次元で非スカラーのインデックスによる参照</a></td></tr><tr><td><code>setindex!(A, I...)</code></td><td>スカラーの <code>setindex!()</code>による定義</td><td><a href="arrays.html#man-array-indexing-1">多次元で非スカラーのインデックスによる代入</a></td></tr><tr><td><code>start()</code>/<code>next()</code>/<code>done()</code></td><td>スカラーの <code>getindex()</code>による定義</td><td>繰返し</td></tr><tr><td><code>length(A)</code></td><td><code>prod(size(A))</code></td><td>要素の数</td></tr><tr><td><code>similar(A)</code></td><td><code>similar(A, eltype(A), size(A))</code></td><td>同形・同要素型の可変配列を返す</td></tr><tr><td><code>similar(A, ::Type{S})</code></td><td><code>similar(A, S, size(A))</code></td><td>同形・指定要素型の可変配列を返す</td></tr><tr><td><code>similar(A, dims::NTuple{Int})</code></td><td><code>similar(A, eltype(A), dims)</code></td><td>同要素型でサイズ<strong>dims</strong>の可変配列を返す</td></tr><tr><td><code>similar(A, ::Type{S}, dims::NTuple{Int})</code></td><td><code>Array{S}(dims)</code></td><td>指定形・指定要素型の可変配列を返す</td></tr><tr><td><strong>通常とは異なるインデックス</strong></td><td><strong>デフォルトの定義</strong></td><td><strong>概説</strong></td></tr><tr><td><code>indices(A)</code></td><td><code>map(OneTo, size(A))</code></td><td>妥当なインデックスの<code>AbstractUnitRange</code>を返す</td></tr><tr><td><code>Base.similar(A, ::Type{S}, inds::NTuple{Ind})</code></td><td><code>similar(A, S, Base.to_shape(inds))</code></td><td><code>inds</code>で指定したインデックスの可変配列を返す (下記参照)</td></tr><tr><td><code>Base.similar(T::Union{Type,Function}, inds)</code></td><td><code>T(Base.to_shape(inds))</code></td><td><code>inds</code>で指定したインデックスの<code>T</code>と同様な可変配列を返す (下記参照)</td></tr></table><!--
If a type is defined as a subtype of `AbstractArray`, it inherits a very large set of rich behaviors
including iteration and multidimensional indexing built on top of single-element access.  See
the [arrays manual page](@ref man-multi-dim-arrays) and [standard library section](@ref lib-arrays) for more supported methods.
--><p><code>AbstractArray</code>のサブタイプとして定義された型は、多様な動作を数多く継承していて、反復処理や、1要素アクセスをもとに構築された多次元インデックスなどが利用できます。 その他の利用可能なメソッドについては、[多次元配列のマニュアルページ]（@ ref man-multi-dim-arrays）と[標準ライブラリの配列のセクション]（@ ref lib-arrays）を参照してください。</p><!--
A key part in defining an `AbstractArray` subtype is [`IndexStyle`](@ref). Since indexing is
such an important part of an array and often occurs in hot loops, it's important to make both
indexing and indexed assignment as efficient as possible.  Array data structures are typically
defined in one of two ways: either it most efficiently accesses its elements using just one index
(linear indexing) or it intrinsically accesses the elements with indices specified for every dimension.
 These two modalities are identified by Julia as `IndexLinear()` and `IndexCartesian()`.
 Converting a linear index to multiple indexing subscripts is typically very expensive, so this
provides a traits-based mechanism to enable efficient generic code for all array types.
--><p><code>AbstractArray</code>のサブタイプの定義で重要な部分は<a href="../stdlib/arrays.html#Base.IndexStyle"><code>IndexStyle</code></a> です。 インデックスは配列の重要な部分であり、頻繁にループで使わわれるため、インデックスによる参照と代入をできる限り効率的に行うことは重要です。 配列のデータ構造は、通常、２つの手法のいずれかが定義に採用されます。 一方は、インデックス（線形インデックス）をただ一つ使用して要素にアクセスする最も効率のよい手法で、もう一方は、本質的にはすべての次元に対してインデックスを指定して要素にアクセスする手法です。 これらの2つのモードは、Juliaでは<code>IndexLinear()</code>と<code>IndexCartesian()</code>によって同定されます。 線形インデックスを多重インデックスの添字に変換するのは、通常非常にコストがかかるので、<code>IndexStyle</code>ごとにトレイトに基づくメカニズムを使って、すべての配列の型に対して効率的で汎化的なコードを可能にするメカニズムが備わっています。</p><!--
This distinction determines which scalar indexing methods the type must define. `IndexLinear()`
arrays are simple: just define `getindex(A::ArrayType, i::Int)`.  When the array is subsequently
indexed with a multidimensional set of indices, the fallback `getindex(A::AbstractArray, I...)()`
efficiently converts the indices into one linear index and then calls the above method. `IndexCartesian()`
arrays, on the other hand, require methods to be defined for each supported dimensionality with
`ndims(A)``Int` indices.  For example, the builtin `SparseMatrixCSC` type only supports two dimensions,
so it just defines `getindex(A::SparseMatrixCSC, i::Int, j::Int)()`.  The same holds for `setindex!()`.
--><p>この<code>IndexStyle</code>の違いによって、どのスカラーインデックスのメソッドを型に対して定義しなければならないかが決定します。 <code>IndexLinear()</code>の配列は単純で、<code>getindex(A::ArrayType, i::Int)</code>を定義するだけです。 配列が多次元で複数のインデックスによってインデックス付けされている場合、補助的な関数の<code>getindex(A::AbstractArray, I...)()</code> はインデックスを線形インデックスに効率的に変換し、前述のメソッドを呼び出します。 一方、<code>IndexCartesian()</code> の配列は、<code>ndims(A)</code>、<code>Int</code>の指定によって利用可能となる次元すべてに対して、メソッドを定義する必要があります。 たとえば、標準装備の<code>SparseMatrixCSC</code>型は2次元しか利用可能ではないため、<code>getindex(A::SparseMatrixCSC, i::Int, j::Int)()</code>だけを定義しています。<code>setindex!()</code>に関しても同様です。</p><!--

Returning to the sequence of squares from above, we could instead define it as a subtype of an
`AbstractArray{Int, 1}`:
--><p>上記の二乗の数列に戻ると、別の手法として<code>AbstractArray{Int, 1}</code>のサブタイプを定義することもできます。</p><pre><code class="language-jldoctest">julia&gt; struct SquaresVector &lt;: AbstractArray{Int, 1}`
           count::Int
       end

julia&gt; Base.size(S::SquaresVector) = (S.count,)

julia&gt; Base.IndexStyle(::Type{&lt;:SquaresVector}) = IndexLinear()

julia&gt; Base.getindex(S::SquaresVector, i::Int) = i*i</code></pre><!--
Note that it's very important to specify the two parameters of the `AbstractArray`; the first
defines the [`eltype()`](@ref), and the second defines the [`ndims()`](@ref). That supertype and those three
methods are all it takes for `SquaresVector` to be an iterable, indexable, and completely functional
array:
--><p><code>AbstractArray</code>の2つのパラメータの指定は、非常に重要であることに注意してください。 1番目は<a href="../stdlib/collections.html#Base.eltype"><code>eltype()</code></a> を定義し、2番目は<a href="../stdlib/arrays.html#Base.ndims"><code>ndims()</code></a>を定義します。 このスーパータイプと3つのメソッドのすべてによって、<code>SquaresVector</code>はループとインデックスによるアクセスが可能になり、完全に機能する配列となります。</p><pre><code class="language-jldoctest">julia&gt; s = SquaresVector(7)
7-element SquaresVector:
  1
  4
  9
 16
 25
 36
 49

julia&gt; s[s .&gt; 20]
3-element Array{Int64,1}:
 25
 36
 49

julia&gt; s \ [1 2; 3 4; 5 6; 7 8; 9 10; 11 12; 13 14]
1×2 Array{Float64,2}:
 0.305389  0.335329

julia&gt; s ⋅ s # dot(s, s)
4676</code></pre><!--
As a more complicated example, let's define our own toy N-dimensional sparse-like array type built
on top of [`Dict`](@ref):
--><p>より複雑な例として、N次元で疎な配列型のおもちゃのようなものを<a href="../stdlib/collections.html#Base.Dict"><code>Dict</code></a>を使って定義しましょう。</p><pre><code class="language-jldoctest">julia&gt; struct SparseArray{T,N} &lt;: AbstractArray{T,N}
           data::Dict{NTuple{N,Int}, T}
           dims::NTuple{N,Int}
       end

julia&gt; SparseArray{T}(::Type{T}, dims::Int...) = SparseArray(T, dims);

julia&gt; SparseArray{T,N}(::Type{T}, dims::NTuple{N,Int}) = SparseArray{T,N}(Dict{NTuple{N,Int}, T}(), dims);

julia&gt; Base.size(A::SparseArray) = A.dims

julia&gt; Base.similar(A::SparseArray, ::Type{T}, dims::Dims) where {T} = SparseArray(T, dims)

julia&gt; Base.getindex(A::SparseArray{T,N}, I::Vararg{Int,N}) where {T,N} = get(A.data, I, zero(T))

julia&gt; Base.setindex!(A::SparseArray{T,N}, v, I::Vararg{Int,N}) where {T,N} = (A.data[I] = v)</code></pre><!--
Notice that this is an `IndexCartesian` array, so we must manually define [`getindex()`](@ref) and [`setindex!()`](@ref)
at the dimensionality of the array. Unlike the `SquaresVector`, we are able to define [`setindex!()`](@ref),
and so we can mutate the array:
--><p>これは<code>IndexCartesian</code>の配列なので、 <a href="../stdlib/arrays.html#Base.getindex-Tuple{Type,Vararg{Any,N} where N}"><code>getindex()</code></a> と<a href="../stdlib/arrays.html#Base.setindex!-Tuple{AbstractArray,Any,Vararg{Any,N} where N}"><code>setindex!()</code></a> を次元ごとに手動で定義する必要がある点に注意してください。 <code>SquaresVector</code>配列とは違って、<a href="../stdlib/arrays.html#Base.setindex!-Tuple{AbstractArray,Any,Vararg{Any,N} where N}"><code>setindex!()</code></a>を定義できるので、配列を更新することができます：</p><pre><code class="language-jldoctest">julia&gt; A = SparseArray(Float64, 3, 3)
3×3 SparseArray{Float64,2}:
 0.0  0.0  0.0
 0.0  0.0  0.0
 0.0  0.0  0.0

julia&gt; fill!(A, 2)
3×3 SparseArray{Float64,2}:
 2.0  2.0  2.0
 2.0  2.0  2.0
 2.0  2.0  2.0

julia&gt; A[:] = 1:length(A); A
3×3 SparseArray{Float64,2}:
 1.0  4.0  7.0
 2.0  5.0  8.0
 3.0  6.0  9.0</code></pre><!--
The result of indexing an `AbstractArray` can itself be an array (for instance when indexing by
a `Range`). The `AbstractArray` fallback methods use [`similar()`](@ref) to allocate an `Array` of the
appropriate size and element type, which is filled in using the basic indexing method described
above. However, when implementing an array wrapper you often want the result to be wrapped as
well:
--><p><code>AbstractArray</code>をインデックスを使って参照した値は、それ自体が配列になることもあります（たとえば、<code>Range</code>を使ってインデックス参照した場合）。 <code>AbstractArray</code>の派生した(コンストラクタ)メソッドは<a href="../stdlib/arrays.html#Base.similar-Tuple{AbstractArray}"><code>similar()</code></a> を利用して、適切なサイズと基本型の<code>配列</code>をメモリに割り当て、上述した基本的なインデックスのメソッドを使ってを値を埋めていきます。 しかし、配列のラッパーが実装されているときには、当然、結果をラップしたくなることもよくあるでしょう。</p><pre><code class="language-jldoctest">julia&gt; A[1:2,:]
2×3 SparseArray{Float64,2}:
 1.0  4.0  7.0
 2.0  5.0  8.0</code></pre><!--
In this example it is accomplished by defining `Base.similar{T}(A::SparseArray, ::Type{T}, dims::Dims)`
to create the appropriate wrapped array. (Note that while `similar` supports 1- and 2-argument
forms, in most case you only need to specialize the 3-argument form.) For this to work it's important
that `SparseArray` is mutable (supports `setindex!`). Defining `similar()`, `getindex()` and
`setindex!()` for `SparseArray` also makes it possible to [`copy()`](@ref) the array:
--><p>この例では<code>Base.similar{T}(A::SparseArray, ::Type{T}, dims::Dims)</code>を定義して、適切にラップされた配列を作成しています。 （<code>similar</code>は1引数や2引数の場合も動作しますが、ほとんどの場合、3引数に特化した場合だけが必要になる点に注意してください。） これが動作するには<code>SparseArray</code>が可変（<code>setindex!</code>を利用可能）であることが重要です。 <code>similar()</code>、<code>getindex()</code>、<code>setindex!()</code>を<code>SparseArray</code>に定義すると、配列を <a href="../stdlib/base.html#Base.copy"><code>copy()</code></a>することができるようになります。</p><pre><code class="language-jldoctest">julia&gt; copy(A)
3×3 SparseArray{Float64,2}:
 1.0  4.0  7.0
 2.0  5.0  8.0
 3.0  6.0  9.0</code></pre><!--
In addition to all the iterable and indexable methods from above, these types can also interact
with each other and use most of the methods defined in the standard library for `AbstractArrays`:
--><p>上記のすべての反復可能なメソッドとインデックス可能なメソッドのほかにも、これらの型は相互に利用することができ、標準ライブラリで定義されている<code>AbstractArrays</code>向けのメソッドをほとんど利用できます。</p><pre><code class="language-jldoctest">julia&gt; A[SquaresVector(3)]
3-element SparseArray{Float64,1}:
 1.0
 4.0
 9.0

julia&gt; dot(A[:,1],A[:,2])
32.0</code></pre><!--
If you are defining an array type that allows non-traditional indexing (indices that start at
something other than 1), you should specialize `indices`. You should also specialize [`similar`](@ref)
so that the `dims` argument (ordinarily a `Dims` size-tuple) can accept `AbstractUnitRange` objects,
perhaps range-types `Ind` of your own design. For more information, see [Arrays with custom indices](@ref).
--><p>通常ではない（1以外から始まる)インデックスを使うには、<code>indices</code>を特化させる必要があります。 また引数の<code>dims</code>（通常は<code>Dims</code>のサイズのタプル）が<code>AbstractUnitRange</code>オブジェクト、ひょっとすると独自設計の範囲型である<code>Ind</code>を受けとれるようにするには、<a href="../stdlib/arrays.html#Base.similar-Tuple{AbstractArray}"><code>similar</code></a>を特化する必要があります。 詳細については、<a href="../devdocs/offset-arrays.html#Arrays-with-custom-indices-1">Arrays with custom indices</a>を参照してください。</p><footer><hr/><a class="previous" href="conversion-and-promotion.html"><span class="direction">Previous</span><span class="title">変換と昇格</span></a><a class="next" href="modules.html"><span class="direction">Next</span><span class="title">モジュール</span></a></footer></article></body></html>
